{
  "hash": "eb56bdb6b4319e25a07c7f726bce0a89",
  "result": {
    "markdown": "---\ntitle: \"4 - Désaisonnalisation avec correction des jours ouvrables\"\nsubtitle: |\n  Formation - Désaisonnalisation avec JDemetra+ et RJDemetra\n  ![](img/logo.png){width=1in}\nauthor: \"Alain Quartier-la-Tente\"\nformat: html\nlang: fr\nlanguage:\n title-block-author-single: Auteur\n---\n\n\n\n\n# Importer les jeux de régresseurs « Jours Ouvrables » sous JDemetra+\n\n-   Cliquer sur l'onglet `Providers`\n\n-   Clic-droit sur `Spreadsheets`\n\n    -   Cliquer sur `Open`\n\n    -   Cliquer sur le bouton `…`\n\n    -   Sélectionner le fichier Excel « regcjo.xls » contenant les régresseurs « Jours Ouvrables » créés depuis R à partir de l'objet `regresseurs_JO`.\n\n    -   Cliquer sur `OK`\n\n-   Cliquer sur l'onglet `Workspace`\n\n-   Cliquer sur le `+` à côté d'`Utilities`\n\n-   Clic-droit sur `Variables`\n\n-   Cliquer sur `New`\n\n-   Cliquer sur le `+` à côté de `Variables`\n\n-   Double cliquer sur l'icône `Vars-1`\n\n    -   Que se passe-t-il ?\n\n-   Retourner dans l'onglet `Providers`\n\n-   Faire glisser l'ensemble des séries du fichier « regcjo.xls » dans l'onglet `Vars-1`\n\n-   Renommer les séries en reprenant leur nom d'origine dans le fichier excel « regcjo.xls ».\n\nCe travail peut être très fastidieux... Heureusement depuis R il existe une solution plus automatique !\nCi-dessous un code pour vous éviter de faire ce travail (un peu compliqué mais une fois le code écrit, vous pouvez l'utiliser tel quel !).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# On va créer un nouveau workspace où l'on va ajouter les nouvelles variables\nlibrary(RJDemetra)\nlibrary(rJava)\ncomplete_variables <- function(liste_var, workspace){\n  if(!is.mts(liste_var))\n    stop(\"liste_var doit être de type mts\")\n  context_dictionary <- .jcall(workspace,\"Lec/tstoolkit/algorithm/ProcessingContext;\", \"getContext\")\n  ts_variable_managers <- context_dictionary$getTsVariableManagers()\n  ts_variables <- .jnew(\"ec/tstoolkit/timeseries/regression/TsVariables\")\n  jd_r_variables <- ts_variable_managers$get(\"r\")\n  if (is.null(jd_r_variables)) {\n    ts_variable_managers$set(\"r\",\n                             .jnew(\"ec/tstoolkit/timeseries/regression/TsVariables\"))\n    jd_r_variables <- ts_variable_managers$get(\"r\")\n  }\n  jd_var_names <- jd_r_variables$getNames()\n\n  model_var_names <- colnames(liste_var)\n\n  for (i in seq_along(model_var_names)) {\n    name <- model_var_names[i]\n    dictionary_var <- jd_r_variables$get(name)\n    tsvar <- .jnew(\"ec/tstoolkit/timeseries/regression/TsVariable\",\n                   name, RJDemetra:::ts_r2jd(liste_var[, i]))\n    if (is.null(dictionary_var)) {\n      jd_r_variables$set(name, tsvar)\n    } else {\n      warning(sprintf(\"La variable %s existe déjà\", name))\n    }\n  }\n}\n\n# Pour la création des regresseurs, voir le TP R associé.\n# Par exemple :\nlibrary(rjd3modelling)\nfrenchCalendar <- calendar.new()\ncalendar.holiday(frenchCalendar, \"NEWYEAR\")\ncalendar.holiday(frenchCalendar, \"EASTERMONDAY\") # Lundi de Pâques\ncalendar.holiday(frenchCalendar, \"MAYDAY\") # 1er mai\ncalendar.fixedday(frenchCalendar, 5, 8)\ncalendar.holiday(frenchCalendar, \"WHITMONDAY\") # Lundi de Pentecôte\ncalendar.fixedday(frenchCalendar, 7, 14)\ncalendar.holiday(frenchCalendar, \"ASSUMPTION\") # Assomption\ncalendar.holiday(frenchCalendar, \"ALLSAINTDAY\") # Toussaint\ncalendar.holiday(frenchCalendar, \"ARMISTICE\")\n\nleap_year <- function(start = 1990, end = 2030, frequency = 12){\n  ly <- ts(0, start = start, end = end, frequency = 12)\n  mois_feb <- cycle(ly) == 2\n  annees <- trunc(round(time(ly), 3)) # arrondi car parfois des pbs avec fonction time\n  # On utilise la définition exacte\n  is_ly <- (annees %% 400 == 0) |\n    ((annees %% 4 == 0) & (annees %% 100 != 0))\n  ly[mois_feb] <- 28 - 28.2425\n  ly[mois_feb & is_ly] <- 29 - 28.2425\n  # on change si besoin la fréquence\n  stats::aggregate(ly, nfrequency = frequency)\n}\nfrequency <- 12\nstart <- c(1990,1)\nend = c(2030, 1)\nlength = (end[1] - start[1]) * 12 + end[2] - start[2]\n\nly <- leap_year(frequency = frequency, start = start,\n                end = end)\nreg6 <- htd(frenchCalendar, frequency = frequency, start = start, length = length,\n            groups = c(1, 2, 3, 4, 5, 6, 0))\nreg5 <- htd(frenchCalendar, frequency = frequency, start = start, length = length,\n            groups = c(1, 2, 3, 4, 5, 0, 0))\nreg4 <- htd(frenchCalendar, frequency = frequency, start = start, length = length,\n            groups = c(1, 2, 2, 2, 3, 4, 0))\nreg3 <- htd(frenchCalendar, frequency = frequency, start = start, length = length,\n            groups = c(1, 2, 2, 2, 2, 0, 0))\nreg2 <- htd(frenchCalendar, frequency = frequency, start = start, length = length,\n            groups = c(1, 1, 1, 1, 1, 2, 0))\nreg1 <- htd(frenchCalendar, frequency = frequency, start = start, length = length,\n            groups = c(1, 1, 1, 1, 1, 0, 0))\n\n\nregresseurs_JO <- ts(cbind(reg1, reg2, reg3, reg4, reg5, reg6),\n                     start = start, frequency = frequency)\nregresseurs_JO <- ts.union(regresseurs_JO,\n                           ly)\ncolnames(regresseurs_JO) <- c(\"REG1_semaine\",\n                              sprintf(\"REG2_%s\", c(\"lundi_a_vendredi\", \"samedi\")),\n                              sprintf(\"REG3_%s\", c(\"lundi\", \"mardi_a_vendredi\")),\n                              sprintf(\"REG4_%s\", c(\"lundi\", \"mardi_a_jeudi\", \"vendredi\", \"samedi\")),\n                              sprintf(\"REG5_%s\", c(\"lundi\", \"mardi\", \"mercredi\", \"jeudi\", \"vendredi\")),\n                              sprintf(\"REG6_%s\", c(\"lundi\", \"mardi\", \"mercredi\", \"jeudi\", \"vendredi\", \"samedi\")),\n                              \"leap_year\")\n\n# Création d'un nouveaux\nwk <- new_workspace()\n# regresseurs_JO est l'objet mts qui contient tous vos régresseurs\n# Il doit donc déjà être créé (voir code ci-dessus) !\ncomplete_variables(regresseurs_JO, wk)\nsave_workspace(wk,\"my workspace.xml\")\n```\n:::\n\n\n# Créer une spécification incluant les jeux de régresseurs « jours ouvrables » Insee\n\n-   Cliquer sur l'onglet `Workspace`\n\n-   Double cliquer sur `Seasonal adjustment`\n\n-   Double cliquer sur `specifications`\n\n-   Double cliquer sur `x13`\n\n-   Clic-droit sur `RSA5c`\n\n-   Cliquer sur `Clone`\n\n    -   Que se passe-t-il ?\n\n-   Double-cliquer sur `X13Spec-1`\n\n-   Cliquer sur le `+` à côté de `Calendar`\n\n-   Cliquer sur le `+` à côté de `tradingDays`\n\n-   Cliquer sur `Default` à côté de option\n\n    -   Que se passe-t-il ?.\n\n-   Cliquer sur `UserDefined`\n\n-   Cliquer sur `Unused` à côté de `userVariables`\n\n    -   Que se passe-t-il ?\n\n-   Faire passer les 6 régresseurs du jeu de régresseurs REG6 + leap_year de la gauche vers la droite\n\n-   Cliquer sur le bouton `Done`\n\n-   Cliquer sur `OK`\n\n# Réaliser une désaisonnalisation automatique de vos séries en utilisant la spécification X13Spec-1\n\nVoir exercice 1.\n\n# Analyser les diagnostics relatifs à la correction des effets de calendrier\n\nPour chaque série, répondez aux questions suivantes :\n\n-   Y a-t-il eu une correction des effets de calendrier ?\n\n    -   Si oui, est-ce que tous les coefficients associés aux régresseurs « JO » sont significativement différents de 0 ?\n\n        -   Si non, essayer d'autres jeux de régresseurs « JO »\n\n    -   Y a-t-il eu une correction de l'effet Pâques ?\n\n-   La série CVS-CJO présente-t-elle des effets « Jours Ouvrables » résiduels ?\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}