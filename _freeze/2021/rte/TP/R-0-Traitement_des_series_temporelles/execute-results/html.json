{
  "hash": "194d21344b9d536371a2b4a808f511de",
  "result": {
    "markdown": "---\ntitle: \"0 - Traitement des séries temporelles sous R\"\nsubtitle: |\n  Formation - Désaisonnalisation avec JDemetra+ et RJDemetra\n  ![](img/logo.png){width=1in}\nauthor: \"Alain Quartier-la-Tente\"\nformat: html\nlang: fr\nlanguage:\n title-block-author-single: Auteur\n---\n\n\n\n\n\n> L'objectif de ce TP est d'apprendre à manipuler les séries temporelles sous R en utilisant les packages de bases.\n\nDans R il existe de nombreux packages qui permettent de manipuler les séries temporelles.\nPour n'en citer que quelques-uns :\\\n- Les objets `ts` peuvent être créés à partir du package `stats` ;\\\n- Les objets `zoo` peuvent être créés à partir du package [zoo](https://CRAN.R-project.org/package=zoo) ;\\\n- Les objets `xts` peuvent être créés à partir du package [xts](https://CRAN.R-project.org/package=xts) ;\\\n- Les objets `tis` peuvent être créés à partir du package [tseries](https://CRAN.R-project.org/package=tseries) ;\\\n- Les objets `tsibble` peuvent être créés à partir du package [tsibble](https://CRAN.R-project.org/package=tsibble).\n\n[tsbox](https://CRAN.R-project.org/package=tsbox) permet quand à lui de facilement passer d'une classe à l'autre.\n\nIci nous nous concentrerons essentiellement sur les trois premiers : `ts` stocker les séries temporelles, `zoo` et `xts` pour effectuer certaines manipulations supplémentaires.\n\n# Manipulation des séries temporelles avec `ts()`\n\n## Création d'une série temporelle\n\nLa fonction `ts()` permet de créer des objets séries-temporelles à partir un vecteur (ou une matrice).\nLa syntaxe de base est `ts(vector, start=, end=, frequency=)` où `start` et `end` sont la première et la dernière observation, `frequency` est le nombre d'observations par unité de temps (1=annuelle, 2=semestrielle, 4=trimestrielle, 6=bi-mestrielle, 12=mensuelle, etc.).\n\nPar exemple pour créer une série trimestrielle ayant les valeurs de 1 à 10 et commençant en 1959Q2 :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nts(1:10, frequency = 4, start = c(1959, 2)) # 2ème trimestre de 1959\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Qtr1 Qtr2 Qtr3 Qtr4\n1959         1    2    3\n1960    4    5    6    7\n1961    8    9   10     \n```\n:::\n\n```{.r .cell-code}\n# Équivalent à \nts(1:10, frequency = 4, start = 1959 + 1/4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Qtr1 Qtr2 Qtr3 Qtr4\n1959         1    2    3\n1960    4    5    6    7\n1961    8    9   10     \n```\n:::\n:::\n\n\nOn peut aussi définir l'objet à partir de sa date de fin :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nts(1:10, frequency = 4, end = c(1959, 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Qtr1 Qtr2 Qtr3 Qtr4\n1957    1    2    3    4\n1958    5    6    7    8\n1959    9   10          \n```\n:::\n:::\n\n\nSi l'on directement extraire un sous-ensemble de la série on peut spécifier les paramètres `end` et `start`.\nPar exemple pour ne garder que les valeurs jusqu'en 1960 inclus :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nts(1:10, frequency = 4, start = c(1959, 2), end = c(1960, 4))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Qtr1 Qtr2 Qtr3 Qtr4\n1959         1    2    3\n1960    4    5    6    7\n```\n:::\n:::\n\n\nOu alors utiliser la fonction `window` une fois l'objet créé :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nts_object <- ts(1:10, frequency = 4, start = c(1959, 2))\nwindow(ts_object, end = c(1960, 4))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Qtr1 Qtr2 Qtr3 Qtr4\n1959         1    2    3\n1960    4    5    6    7\n```\n:::\n:::\n\n\nOn peut récupérer les différents attributs avec les fonctions `start()`, `end()` et `frequency()` :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstart(ts_object)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1959    2\n```\n:::\n\n```{.r .cell-code}\nend(ts_object)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1961    3\n```\n:::\n\n```{.r .cell-code}\nfrequency(ts_object)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n:::\n\n\nDeux autres fonctions peuvent aussi être utiles : `time()` crée un série-temporelle à partir des dates de notre série-temporelle et `cycle()` donne la position dans le cycle de chaque observation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntime(ts_object)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        Qtr1    Qtr2    Qtr3    Qtr4\n1959         1959.25 1959.50 1959.75\n1960 1960.00 1960.25 1960.50 1960.75\n1961 1961.00 1961.25 1961.50        \n```\n:::\n\n```{.r .cell-code}\ncycle(ts_object)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Qtr1 Qtr2 Qtr3 Qtr4\n1959         2    3    4\n1960    1    2    3    4\n1961    1    2    3     \n```\n:::\n:::\n\n\n::: callout-note\n## Exercice\nExtraire toutes les données du 2ème trimestre de l'objet `ts_object`\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\n\n::: {.cell}\n\n```{.r .cell-code}\nts_object[cycle(ts_object) == 2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 5 9\n```\n:::\n:::\n\n:::\n\n::: callout-note\n## Exercice\nCréer une série temporelle mensuelle qui commence en 2000, qui se termine en janvier 2020, qui vaut 1 en avril 2009 et 0 à toutes les autres dates \n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\n\n::: {.cell}\n\n```{.r .cell-code}\nindicatrice <- ts(0, start = 2000, end = 2020, frequency = 12)\nwindow(indicatrice, start = c(2005, 4), end = c(2005, 4)) <- 1\nindicatrice\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n2000   0   0   0   0   0   0   0   0   0   0   0   0\n2001   0   0   0   0   0   0   0   0   0   0   0   0\n2002   0   0   0   0   0   0   0   0   0   0   0   0\n2003   0   0   0   0   0   0   0   0   0   0   0   0\n2004   0   0   0   0   0   0   0   0   0   0   0   0\n2005   0   0   0   1   0   0   0   0   0   0   0   0\n2006   0   0   0   0   0   0   0   0   0   0   0   0\n2007   0   0   0   0   0   0   0   0   0   0   0   0\n2008   0   0   0   0   0   0   0   0   0   0   0   0\n2009   0   0   0   0   0   0   0   0   0   0   0   0\n2010   0   0   0   0   0   0   0   0   0   0   0   0\n2011   0   0   0   0   0   0   0   0   0   0   0   0\n2012   0   0   0   0   0   0   0   0   0   0   0   0\n2013   0   0   0   0   0   0   0   0   0   0   0   0\n2014   0   0   0   0   0   0   0   0   0   0   0   0\n2015   0   0   0   0   0   0   0   0   0   0   0   0\n2016   0   0   0   0   0   0   0   0   0   0   0   0\n2017   0   0   0   0   0   0   0   0   0   0   0   0\n2018   0   0   0   0   0   0   0   0   0   0   0   0\n2019   0   0   0   0   0   0   0   0   0   0   0   0\n2020   0                                            \n```\n:::\n:::\n\n:::\n\nPour tracer un graphique il suffit maintenant d'utiliser les fonctions `plot()` et `lines()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(ts_object * 2)\nlines(ts_object, col = \"red\")\n```\n\n::: {.cell-output-display}\n![](R-0-Traitement_des_series_temporelles_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n## Séries multivariées\n\nDe la même façon que précédemment on peut créer une série temporelle multivariée.\nCette fois-ci l'objet créé est à la fois `mts`, `ts` et `matrix`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmts <- ts(matrix(rnorm(300), 100, 3), start = c(1961, 1), frequency = 12)\n```\n:::\n\n\nOn peut accéder à la première variable de la même façon que dans une matrice : par son nom ou son numéro de colonne :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(mts)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Series 1\" \"Series 2\" \"Series 3\"\n```\n:::\n\n```{.r .cell-code}\n# mts[,1] # ou de façon équivalente :\nmts[, \"Series 1\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             Jan         Feb         Mar         Apr         May         Jun\n1961  0.48457656 -0.35498297 -4.07604013 -0.94818736  0.49777745  0.83790218\n1962 -0.59378326 -0.12329912  0.14425366 -1.87033256  2.07358714 -0.79759979\n1963 -1.32728072  0.43801327  0.27269378  0.50397756 -0.71284225 -0.28389309\n1964 -0.65843830 -1.23378701 -0.10760678  0.23627752  0.27659537  0.87856469\n1965 -0.16224075 -1.38098691 -0.84078131 -0.57084346  0.24409719  1.32974484\n1966 -0.12101717 -0.71629919  0.70740582  0.27336550  0.47031910 -2.14256903\n1967  0.49154784 -0.46248882  1.53373504  1.69799441 -1.35614340  0.81509954\n1968  1.46840899 -0.28817877 -0.05167282 -0.05508327 -0.75298834 -0.35390815\n1969 -0.98758474  1.23111712 -1.06354431 -1.68894505                        \n             Jul         Aug         Sep         Oct         Nov         Dec\n1961  1.00576280 -0.08247037 -0.70366556 -0.26087010  1.04846904 -1.71825380\n1962  0.22070799  1.01982402  0.53763430 -1.02860299 -0.61588759  1.56678439\n1963 -0.84023146  1.39245730 -0.11318523 -1.47566125 -0.48108957 -1.29835261\n1964  0.07445877 -0.56883127  0.60440919 -0.65243419  0.98461073 -2.47754589\n1965  0.88815020  1.72164040 -1.30703847  0.28122870 -0.49543356  1.08880197\n1966  3.24831138  1.01697072  1.42221349 -1.13667101 -1.23098253  0.48852850\n1967 -1.54316150  0.57076612  0.40654318  0.10156154  0.12003689  0.55890502\n1968  0.97194091  0.05395929 -1.45792337 -0.16589613 -1.35823982 -0.26852694\n1969                                                                        \n```\n:::\n:::\n\n\nEt avec les même fonctions que pour les matrices on peut récupérer les noms des colonnes (`colnames`), le nombre de variables (`ncol`), etc.\n\n::: {.callout-important}\n## Attention\nUne source classique d'erreur est de manipuler des séries-temporelles uni et multivariées et de vouloir utiliser les fonctions liées aux matrices sur les séries univariées. Par exemple, `colnames(ts_object)` renverra toujours l'objet `NULL`. Une solution est de tester si l'objet est multivarié avec la fonction `is.mts()`.\n:::\n\n## Manipulation basiques\n\nPour concaténer plusieurs séries temporelles, les fonctions deux fonctions suivantes peuvent `ts.union()` et `ts.intersect()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nts_object2 <- ts(1:10, frequency = 4, start = c(1960, 1))\nts.union(ts_object, ts_object2) # on garde toute la couverture temporelle en rajoutant des NA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        ts_object ts_object2\n1959 Q2         1         NA\n1959 Q3         2         NA\n1959 Q4         3         NA\n1960 Q1         4          1\n1960 Q2         5          2\n1960 Q3         6          3\n1960 Q4         7          4\n1961 Q1         8          5\n1961 Q2         9          6\n1961 Q3        10          7\n1961 Q4        NA          8\n1962 Q1        NA          9\n1962 Q2        NA         10\n```\n:::\n\n```{.r .cell-code}\nts.intersect(ts_object, ts_object2) # on ne garde que les périodes communes\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        ts_object ts_object2\n1960 Q1         4          1\n1960 Q2         5          2\n1960 Q3         6          3\n1960 Q4         7          4\n1961 Q1         8          5\n1961 Q2         9          6\n1961 Q3        10          7\n```\n:::\n:::\n\n\nOn va maintenant utiliser la série d'indice de production industrielle de la France (CVS-CJO) :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nipi_fr_manuf <- ts(c(94.2, 96.69, 95.66, 95.06, 95.96, 93.97, 94.16, 93.4, \n94.12, 94.29, 92.42, 93.01, 94.98, 93.31, 93.76, 93.06, 91.93, \n93.41, 91.68, 92.98, 93.42, 92.39, 93.74, 92.69, 93.12, 92.57, \n93.49, 92.59, 92.85, 91.74, 91.23, 91.53, 90.08, 90.47, 89.97, \n88.44, 88.66, 87.86, 87.38, 87.42, 87.14, 86.24, 87.67, 86.86, \n87.2, 87.68, 85.93, 86.25, 88.14, 87.71, 88.21, 89.59, 90.38, \n90.76, 91.67, 92.18, 91.79, 93.02, 94.54, 94.04, 94.17, 94.56, \n93.94, 94.29, 93.59, 94.34, 94.79, 94.04, 94.62, 93.51, 92.59, \n94.9, 93.89, 93.19, 94.19, 93.67, 95.19, 94.72, 92.82, 95.49, \n95.13, 94.21, 95.42, 95.34, 94.39, 96.09, 97.14, 100.02, 97.84, \n98.59, 98.72, 102.9, 100.51, 103.23, 100.91, 103.1, 103.21, 103.76, \n102.15, 103.37, 104.98, 104.21, 105.32, 102.65, 104.34, 104.07, \n104.39, 103.62, 104.75, 103.36, 103.8, 104.89, 105.49, 106.69, \n106.91, 104.6, 107.76, 109.36, 109.26, 108.33, 109.12, 109.6, \n110.2, 110.81, 112.57, 110.92, 112.15, 110.86, 111.53, 112.75, \n112.67, 114.3, 113.32, 114.09, 114.65, 112.12, 113.06, 113.27, \n111.34, 114.36, 111.94, 112.04, 109.81, 110.12, 110.98, 111.91, \n112.23, 112.86, 111.23, 111.13, 109.96, 112.59, 110.62, 109.69, \n111.26, 108.05, 110.05, 110.39, 110.92, 110.7, 107.72, 107.26, \n109.22, 108.78, 108.66, 110.62, 108.8, 109.42, 110.12, 111.6, \n110.61, 111, 110.22, 111.69, 112.3, 107.68, 111.92, 112.66, 110.38, \n110.74, 113.16, 111.04, 108.72, 112, 110.35, 110.3, 110.21, 109.04, \n112.63, 109.26, 113.55, 112.07, 111.16, 110.64, 112.98, 111.54, \n114.46, 114.28, 112.29, 111.52, 113.52, 112.84, 112.1, 114.24, \n113.24, 114.18, 114.73, 113.28, 115.9, 114.88, 115.04, 115.72, \n112.57, 115.17, 113.71, 113.82, 115.29, 116.48, 114.36, 116.12, \n111.24, 110.64, 111.49, 109.8, 109.25, 107.21, 100.8, 99.34, \n94.87, 93.66, 92.19, 92.2, 93.49, 95.23, 94.71, 96.27, 97.09, \n96.3, 97.66, 96.56, 97.12, 96.6, 98.78, 98.7, 99.27, 99.03, 99.69, \n98.63, 99.98, 99.7, 100.82, 101.79, 104.09, 105.03, 103.59, 102.21, \n105.56, 101.55, 103.08, 101.93, 101.22, 101.5, 104.35, 102.1, \n101.05, 100.14, 101.87, 100.16, 99.79, 99.16, 100.01, 101.92, \n100.11, 97.66, 97.59, 99.12, 98.02, 98.55, 98.78, 100.31, 100.31, \n99.64, 98.56, 98.37, 98.54, 99.16, 100.35, 99.27, 98.24, 99.95, \n99.43, 99.53, 96.53, 99.06, 100.11, 98.2, 99.17, 97.91, 96.93, \n99.45, 99.02, 99.38, 99.74, 99.38, 100.85, 100.02, 98.66, 100.22, \n101.23, 100.64, 99.94, 100.92, 102.39, 100.8, 99.54, 100.73, \n99.76, 99.07, 99.77, 101.63, 100.4, 99.4, 102.76, 100.97, 100.16, \n101.11, 102.62, 101.82, 103.7, 103.02, 103.59, 103.54, 104.38, \n105.57, 105.52, 105.93, 103.59, 102.87, 103.82, 103.83, 102.5, \n104.23, 104.04, 104.61, 103.38, 104.22, 103.42, 103.7, 104.93, \n105.75, 104.38, 104.29, 105.98, 103.72, 104.07, 103.1, 103.88, \n104.37), start = 1990, frequency = 12)\n```\n:::\n\n\nPour calculer la série retardée/avancée, il suffit d'utiliser la fonction `lag()` :\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# série retardée d'un mois : en février 2010 on a la valeur de janvier 2010\nlag(ipi_fr_manuf, k = -1) \n```\n:::\n\n\nLa fonction `diff` permet de calculer la différence entre deux périodes\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiff(ipi_fr_manuf, k = 1)\n```\n:::\n\n\n::: callout-note\n## Exercice\nÉcrire une fonction `ev()` qui calcule l'évolution mensuelle si la série en entrée est mensuelle, l'évolution trimestrielle si la série en entrée est trimestrielle, etc.\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\n\n::: {.cell}\n\n```{.r .cell-code}\nev <- function(x){\n  result <- (x/lag(x, k = -1) - 1) * 100\n  return(result)\n}\n# Ou de manière équivalente :\nev2 <- function(x){\n  # Attention ici c'est bien k = 1 dans la fonction diff\n  # et k = -1 dans la fonction lag\n  result <- (diff(x, k = 1) /lag(x, k = -1)) * 100\n  return(result)\n}\n\n#################################################\n# Remarque : pour des raisons informatiques ces deux fonctions ne donnent pas exactement\n# le même résultat. C'est un problème récurrent lorsque l'on\n# souhaite tester l'égalité entre deux séries temporelles :\nall (ev(ipi_fr_manuf) == ev2(ipi_fr_manuf))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n# Une solution est plutôt d'utiliser la fonction all.equal():\nisTRUE(all.equal(ev(ipi_fr_manuf), ev2(ipi_fr_manuf)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n:::\n\n# Utilisation de `xts` et `zoo`\n\n## Utilisation de `xts`\n\nUn des avantages du package `xts` est qu'il permet d'appliquer une fonction à chaque période d'une série temporelle (par exemple à toutes les données trimestrielles, annuelles, etc.).\nIl s'agit des fonctions `apply.monthly()`, `apply.quarterly()`, `apply.yearly()`, etc.\nPour cela il faut auparavant convertir les données au format `xts`.\\\n\nPar exemple pour calculer la moyenne annuelle :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(xts)\nmoy_an <- apply.yearly(as.xts(ipi_fr_manuf), mean)\nmoy_an\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n              [,1]\ndéc 1990  94.41167\ndéc 1991  93.11250\ndéc 1992  91.50667\ndéc 1993  87.19083\ndéc 1994  91.00250\ndéc 1995  94.11167\ndéc 1996  94.43833\ndéc 1997  99.45333\ndéc 1998 103.83917\ndéc 1999 106.26667\ndéc 2000 111.45667\ndéc 2001 112.51000\ndéc 2002 111.04250\ndéc 2003 109.37833\ndéc 2004 110.91000\ndéc 2005 111.02750\ndéc 2006 112.63083\ndéc 2007 114.35333\ndéc 2008 110.16833\ndéc 2009  95.01917\ndéc 2010  99.17583\ndéc 2011 103.01750\ndéc 2012  99.88167\ndéc 2013  99.15500\ndéc 2014  98.70917\ndéc 2015 100.00000\ndéc 2016 100.60167\ndéc 2017 103.41333\ndéc 2018 103.68417\noct 2019 104.44700\n```\n:::\n:::\n\n\n::: callout-note\n## Exercice\nCalculer l'évolution trimestrielle de `ipi_fr_manuf`.\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\n\n::: {.cell}\n\n```{.r .cell-code}\n# Tout d'abord on prolonge l'IPI par des valeurs manquantes jusqu'à la fin \n# de l'année, sinon la dernière somme sur le trimestre est fausse.\nipi_fr_manuf_prolonge <- window(ipi_fr_manuf, end = c(2019, 12), extend = TRUE)\n\nsomme_trim <- apply.quarterly(as.xts(ipi_fr_manuf_prolonge), sum)\n# Attention la fonction lag n'agit pas pareil pour les objets xts et ts :\n# il faut ici utiliser l'option k = 1\nevol_trim <- (somme_trim/lag(somme_trim, k = 1) - 1) * 100\n\n# On peut utiliser la fonction format() \n# si l'on veut convertir automatiquement en un objet ts\nstart_year <- as.numeric(format(start(evol_trim), \"%Y\"))\nstart_quarter <- as.numeric(substr(quarters(start(evol_trim)), 2, 2))\nts(evol_trim, start = c(start_year, start_quarter), frequency = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            Qtr1        Qtr2        Qtr3        Qtr4\n1990          NA -0.54440761 -1.16144426 -0.69582505\n1991  0.83297583 -1.29409679 -0.11494253  0.26611047\n1992  0.12911556 -0.71638370 -1.56576954 -1.45140009\n1993 -1.85212734 -1.17468738  0.35659509 -0.71447675\n1994  1.61625491  2.52594107  1.81361504  2.16224060\n1995  0.37997159 -0.15919624  0.43583020 -0.86434997\n1996  0.09608541  0.82127493 -0.04936878  0.53979678\n1997  0.92992245  3.07002295  1.91600607  1.69132493\n1998  0.61189949  1.11283644 -0.07998464 -0.07364478\n1999 -0.05447321  1.65432336  0.69385309  2.40548752\n2000  0.60253861  1.63565609  0.07179180  1.54839481\n2001  0.68880254 -1.05537040 -0.23932634 -1.67930340\n2002  0.94888092  0.02984006 -0.61153869 -1.25161329\n2003  0.71732523 -1.71414775  0.30090887  0.66736056\n2004  1.06130641  0.17452532 -0.30338530  0.56643567\n2005 -0.25765474 -0.08110056 -0.23147452  0.90394118\n2006 -0.02986144  1.64286994 -0.86693311  0.54842439\n2007  0.87564125  0.55823469 -0.21217230 -0.18349693\n2008  1.00087540 -2.34882847 -2.20710059 -7.01579234\n2009 -8.66438913  0.07124537  2.54520860  0.85048773\n2010  0.68153656  1.53846154  0.43771044  1.34428428\n2011  3.44017730 -1.08407150 -0.99896547  0.56166933\n2012 -1.58792012 -1.30337227  0.97957273 -2.53939876\n2013  0.33291436  1.66243440 -1.59528409  1.12024909\n2014 -0.38824553 -0.83999731  0.79967471 -1.07234100\n2015  1.30823338  0.70772120 -0.04662781  0.46316351\n2016  0.40796020 -1.04713771  0.74776339  0.44068920\n2017  0.25071751  1.53015894  0.96259804  1.76880357\n2018 -2.12604883  0.09024107  0.47333849 -0.22113258\n2019  1.19483523 -0.33961785 -0.93633555          NA\n```\n:::\n:::\n\n:::\n\n## Utilisation de `zoo`\n\nLe package `zoo` donne un ensemble d'outils qui permettent de manipuler les séries-temporelles.\nDe nombreux packages (dont `xts`) sont d'ailleurs basés sur ce format.\nIl permet notamment de faire des imputations de données manquantes selon différentes fonctions (toutes les fonctions commençant par `na.`) et de mieux gérer le format des dates associées aux séries temporelles (ce qui permet de faire des manipulations avec la fonction `format`, ce qui permet par exemple plus facilement exporter des séries temporelles sous Excel).\nLe calcul de l'évolution trimestrielle aurait par exemple pu être faite avec ce package :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsomme_trim <- aggregate(as.zoo(ipi_fr_manuf_prolonge), yearqtr, sum)\nsomme_trim <- as.ts(somme_trim) #La conversion en ts est plus simple depuis un objet zoo\nevol_trim <- ev(somme_trim)\nevol_trim\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            Qtr1        Qtr2        Qtr3        Qtr4\n1990             -0.54440761 -1.16144426 -0.69582505\n1991  0.83297583 -1.29409679 -0.11494253  0.26611047\n1992  0.12911556 -0.71638370 -1.56576954 -1.45140009\n1993 -1.85212734 -1.17468738  0.35659509 -0.71447675\n1994  1.61625491  2.52594107  1.81361504  2.16224060\n1995  0.37997159 -0.15919624  0.43583020 -0.86434997\n1996  0.09608541  0.82127493 -0.04936878  0.53979678\n1997  0.92992245  3.07002295  1.91600607  1.69132493\n1998  0.61189949  1.11283644 -0.07998464 -0.07364478\n1999 -0.05447321  1.65432336  0.69385309  2.40548752\n2000  0.60253861  1.63565609  0.07179180  1.54839481\n2001  0.68880254 -1.05537040 -0.23932634 -1.67930340\n2002  0.94888092  0.02984006 -0.61153869 -1.25161329\n2003  0.71732523 -1.71414775  0.30090887  0.66736056\n2004  1.06130641  0.17452532 -0.30338530  0.56643567\n2005 -0.25765474 -0.08110056 -0.23147452  0.90394118\n2006 -0.02986144  1.64286994 -0.86693311  0.54842439\n2007  0.87564125  0.55823469 -0.21217230 -0.18349693\n2008  1.00087540 -2.34882847 -2.20710059 -7.01579234\n2009 -8.66438913  0.07124537  2.54520860  0.85048773\n2010  0.68153656  1.53846154  0.43771044  1.34428428\n2011  3.44017730 -1.08407150 -0.99896547  0.56166933\n2012 -1.58792012 -1.30337227  0.97957273 -2.53939876\n2013  0.33291436  1.66243440 -1.59528409  1.12024909\n2014 -0.38824553 -0.83999731  0.79967471 -1.07234100\n2015  1.30823338  0.70772120 -0.04662781  0.46316351\n2016  0.40796020 -1.04713771  0.74776339  0.44068920\n2017  0.25071751  1.53015894  0.96259804  1.76880357\n2018 -2.12604883  0.09024107  0.47333849 -0.22113258\n2019  1.19483523 -0.33961785 -0.93633555          NA\n```\n:::\n:::\n\n\nPour le prochain exercice, utiliser la série suivante :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nserie_avec_NA <- ts(c(NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 0, 0, 0, 0, \n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NA, \n  NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, \n  NA, NA, NA, NA, NA, NA, NA, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, NA, NA, NA, NA, NA, NA, \n  NA, NA, NA, NA, NA, NA), start= 2000, frequency = 12)\n```\n:::\n\n\n::: callout-note\n## Exercice\nSur la série `serie_avec_NA`, utiliser les différentes fonctions du package `zoo` pour :\n1. Enlever les valeurs manquantes au début de la série ;\n2. Remplacer les valeurs manquantes à la fin de la série par la dernière valeur observée.\n3. Interpoler de manière linéaire les valeurs manquantes entre les 0 et les 1.\n:::\n\n::: {.callout-caution collapse=\"true\"}\n## Indice\nLes trois fonctions à utiliser sont : `na.trim()`, `na.locf` et `na.approx()`\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\n\n::: {.cell}\n\n```{.r .cell-code}\n# D'abord on enlève les valeurs manquantes au début de la série\netape_1 <- na.trim(serie_avec_NA, sides = \"left\")\netape_1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n2001   0   0   0   0   0   0   0   0   0   0   0   0\n2002   0   0   0   0   0   0   0   0   0   0   0   0\n2003  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA\n2004  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA\n2005   1   1   1   1   1   1   1   1   1   1   1   1\n2006   1   1   1   1   1   1   1   1   1   1   1   1\n2007  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA\n```\n:::\n\n```{.r .cell-code}\n# Ensuite on interpole\netape_2 <- na.approx(etape_1, na.rm = FALSE)\netape_2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Jan  Feb  Mar  Apr  May  Jun  Jul  Aug  Sep  Oct  Nov  Dec\n2001 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00\n2002 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00\n2003 0.04 0.08 0.12 0.16 0.20 0.24 0.28 0.32 0.36 0.40 0.44 0.48\n2004 0.52 0.56 0.60 0.64 0.68 0.72 0.76 0.80 0.84 0.88 0.92 0.96\n2005 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00\n2006 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00\n2007   NA   NA   NA   NA   NA   NA   NA   NA   NA   NA   NA   NA\n```\n:::\n\n```{.r .cell-code}\n# Enfin on remplace les valeurs à la fin de la série\netape_3 <- na.locf(etape_2)\netape_3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Jan  Feb  Mar  Apr  May  Jun  Jul  Aug  Sep  Oct  Nov  Dec\n2001 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00\n2002 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00\n2003 0.04 0.08 0.12 0.16 0.20 0.24 0.28 0.32 0.36 0.40 0.44 0.48\n2004 0.52 0.56 0.60 0.64 0.68 0.72 0.76 0.80 0.84 0.88 0.92 0.96\n2005 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00\n2006 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00\n2007 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00\n```\n:::\n:::\n\n:::\n\n::: callout-note\n## Exercice\nÀ l'aide des fonctions `as.yearmon()` et `format()`, créer un data.frame contenant une colonne \"date\" qui contient les dates au format JJ/MM/YYYY et une deuxième colonnes avec les valeurs de `ipi_fr_manuf`.\n:::\n\n::: {.callout-caution collapse=\"true\"}\n## Indice\nLa fonction `as.yearmon()` doit être appliquée sur `time(ipi_fr_manuf)`. Pour la fonction `format` regarder l'aide `?format.Date`.\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\n\n::: {.cell}\n\n```{.r .cell-code}\ndates <- as.yearmon(time(ipi_fr_manuf))\ndates <- format(dates, \"%d/%m/%Y\")\ndonnees_formatees <- data.frame(date = dates, ipi = ipi_fr_manuf)\nhead(donnees_formatees)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        date   ipi\n1 01/01/1990 94.20\n2 01/02/1990 96.69\n3 01/03/1990 95.66\n4 01/04/1990 95.06\n5 01/05/1990 95.96\n6 01/06/1990 93.97\n```\n:::\n:::\n\n:::\n\nIl peut également être utile d'exporter un objet R `ts` ou `mts` vers un fichier Excel, tout en rajoutant une colonne \"date\" qui sera au format date.\nCi-dessous un exemple en utilisant le package XLConnect :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(XLConnect)\nts2xls <- function(x, file, sheet=\"Feuille 1\", format = \"dd/mm/yyyy\"){\n  wb <- loadWorkbook(file, create = TRUE)\n  createSheet(wb, sheet)\n  if(is.mts(x)){\n    col <- c(\"date\", colnames(x))\n  }else{\n    col <- c(\"date\", \"x\")\n  }\n  # Le titre\n  writeWorksheet(wb,matrix(col,nrow = 1),\n                 sheet = sheet,startCol = 1,startRow =1,\n                 header = FALSE)\n\n  # Petit trick pour que la colonne date soit au format date d'Excel\n  csDate <- getOrCreateCellStyle(wb, name = \"date\")\n  setDataFormat(csDate, format = format)\n  date <- as.Date(format(zoo::as.Date((time(x))), \"%d/%m/%Y\"),\n                  \"%d/%m/%Y\")\n  writeWorksheet(wb,date,sheet = sheet,\n                 startCol = 1,startRow = 2,\n                 header = FALSE)\n  setCellStyle(wb, sheet = sheet, row = seq_along(date)+1,\n               col = 1,\n               cellstyle = csDate)\n  # Fin colonne date\n\n  # Autres colonnes\n  writeWorksheet(wb,x,sheet = sheet,startCol = 2,startRow = 2,\n                 header = FALSE)\n  setColumnWidth(wb, sheet, column = seq_along(col), width = -1)\n  saveWorkbook(wb, file)\n}\n```\n:::\n",
    "supporting": [
      "R-0-Traitement_des_series_temporelles_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}