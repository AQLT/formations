{
  "hash": "1cbe6218884145abd27441a4e9e1bc4b",
  "result": {
    "markdown": "---\ntitle: \"1 - Traitement des séries temporelles sous R\"\nsubtitle: |\n  Analyse des séries temporelles avec R\nauthor: \"Alain Quartier-la-Tente\"\nformat: html\nlang: fr\nlanguage: \n title-block-author-single: Auteur\n---\n\n\n\n\n> L'objectif de ce TP est d'apprendre à manipuler les séries temporelles sous R en utilisant les packages de bases.\n\nDans R il existe de nombreux packages qui permettent de manipuler les séries temporelles.\nPour n'en citer que quelques-uns :\\\n- Les objets `ts` peuvent être créés à partir du package `stats` ;\\\n- Les objets `zoo` peuvent être créés à partir du package [zoo](https://CRAN.R-project.org/package=zoo) ;\\\n- Les objets `xts` peuvent être créés à partir du package [xts](https://CRAN.R-project.org/package=xts) ;\\\n- Les objets `tis` peuvent être créés à partir du package [tseries](https://CRAN.R-project.org/package=tseries) ;\\\n- Les objets `tsibble` peuvent être créés à partir du package [tsibble](https://CRAN.R-project.org/package=tsibble).\n\n[tsbox](https://CRAN.R-project.org/package=tsbox) permet quand à lui de facilement passer d'une classe à l'autre.\n\nIci nous nous concentrerons essentiellement sur les trois premiers : `ts` stocker les séries temporelles, `zoo` et `xts` pour effectuer certaines manipulations supplémentaires.\n\nLes packages suivants seront utilisés :\n\n\n::: {.cell}\n\n```{.r .cell-code}\npackages_to_install <- c(\"zoo\", \"xts\", \"dplyr\", \"tsibble\", \"lubridate\", \"XLConnect\")\n\npackages <- installed.packages()[,\"Package\"][! packages_to_install %in% installed.packages()[,\"Package\"]]\nif (length(packages) > 0) {\n\tinstall.packages(packages)\n}\n```\n:::\n\n\n# Manipulation des séries temporelles avec `ts()`\n\n## Création d'une série temporelle\n\nLa fonction `ts()` permet de créer des objets séries-temporelles à partir un vecteur (ou une matrice).\nLa syntaxe de base est `ts(vector, start=, end=, frequency=)` où `start` et `end` sont la première et la dernière observation, `frequency` est le nombre d'observations par unité de temps (1=annuelle, 2=semestrielle, 4=trimestrielle, 6=bi-mestrielle, 12=mensuelle, etc.).\n\nPar exemple pour créer une série trimestrielle ayant les valeurs de 1 à 10 et commençant en 1959Q2 :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nts(1:10, frequency = 4, start = c(1959, 2)) # 2ème trimestre de 1959\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Qtr1 Qtr2 Qtr3 Qtr4\n1959         1    2    3\n1960    4    5    6    7\n1961    8    9   10     \n```\n:::\n\n```{.r .cell-code}\n# Équivalent à \nts(1:10, frequency = 4, start = 1959 + 1/4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Qtr1 Qtr2 Qtr3 Qtr4\n1959         1    2    3\n1960    4    5    6    7\n1961    8    9   10     \n```\n:::\n:::\n\n\nOn peut aussi définir l'objet à partir de sa date de fin :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nts(1:10, frequency = 4, end = c(1959, 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Qtr1 Qtr2 Qtr3 Qtr4\n1957    1    2    3    4\n1958    5    6    7    8\n1959    9   10          \n```\n:::\n:::\n\n\nSi l'on directement extraire un sous-ensemble de la série on peut spécifier les paramètres `end` et `start`.\nPar exemple pour ne garder que les valeurs jusqu'en 1960 inclus :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nts(1:10, frequency = 4, start = c(1959, 2), end = c(1960, 4))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Qtr1 Qtr2 Qtr3 Qtr4\n1959         1    2    3\n1960    4    5    6    7\n```\n:::\n:::\n\n\nOu alors utiliser la fonction `window` une fois l'objet créé :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nts_object <- ts(1:10, frequency = 4, start = c(1959, 2))\nwindow(ts_object, end = c(1960, 4))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Qtr1 Qtr2 Qtr3 Qtr4\n1959         1    2    3\n1960    4    5    6    7\n```\n:::\n:::\n\n\nOn peut récupérer les différents attributs avec les fonctions `start()`, `end()` et `frequency()` :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstart(ts_object)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1959    2\n```\n:::\n\n```{.r .cell-code}\nend(ts_object)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1961    3\n```\n:::\n\n```{.r .cell-code}\nfrequency(ts_object)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n:::\n\n\nDeux autres fonctions peuvent aussi être utiles : `time()` crée un série-temporelle à partir des dates de notre série-temporelle et `cycle()` donne la position dans le cycle de chaque observation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntime(ts_object)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        Qtr1    Qtr2    Qtr3    Qtr4\n1959         1959.25 1959.50 1959.75\n1960 1960.00 1960.25 1960.50 1960.75\n1961 1961.00 1961.25 1961.50        \n```\n:::\n\n```{.r .cell-code}\ncycle(ts_object)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Qtr1 Qtr2 Qtr3 Qtr4\n1959         2    3    4\n1960    1    2    3    4\n1961    1    2    3     \n```\n:::\n:::\n\n\n::: callout-note\n## Exercice\nExtraire toutes les données du 2ème trimestre de l'objet `ts_object`\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\n\n::: {.cell}\n\n```{.r .cell-code}\nts_object[cycle(ts_object) == 2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 5 9\n```\n:::\n:::\n\n\nAutre option : utiliser la fonction `window()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwindow(ts_object, frequency = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTime Series:\nStart = 1959.25 \nEnd = 1961.25 \nFrequency = 1 \n[1] 1 5 9\n```\n:::\n:::\n\n\nExplication : lorsque l'on spécifie le paramètre `frequency` dans la fonction `window()`, on change la fréquence de la série. \nDans notre cas, on veut extraire les valeurs du deuxième trimestre : on veut donc une série annuelle qui contient toutes les valeurs des deuxièmes trimestres. \nLa première observation de `ts_object` étant un deuxième trimestre, cela donne ce que l'on veut. \nPour extraire les valeurs des troisièmes trimestres il faut en plus changer la date de début :\n\n::: {.cell}\n\n```{.r .cell-code}\nwindow(ts_object, start = c(1950, 3), frequency = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTime Series:\nStart = 1959.25 \nEnd = 1961.25 \nFrequency = 1 \n[1] 1 5 9\n```\n:::\n:::\n\n:::\n\n::: callout-note\n## Exercice\nCréer une série temporelle mensuelle qui commence en 2000, qui se termine en janvier 2020, qui vaut 1 en avril 2009 et 0 à toutes les autres dates.\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\nOption 1 : utiliser la fonction `window()`\n\n::: {.cell}\n\n```{.r .cell-code}\nindicatrice <- ts(0, start = 2000, end = 2020, frequency = 12)\nwindow(indicatrice, start = c(2009, 4), end = c(2009, 4)) <- 1\nindicatrice\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n2000   0   0   0   0   0   0   0   0   0   0   0   0\n2001   0   0   0   0   0   0   0   0   0   0   0   0\n2002   0   0   0   0   0   0   0   0   0   0   0   0\n2003   0   0   0   0   0   0   0   0   0   0   0   0\n2004   0   0   0   0   0   0   0   0   0   0   0   0\n2005   0   0   0   0   0   0   0   0   0   0   0   0\n2006   0   0   0   0   0   0   0   0   0   0   0   0\n2007   0   0   0   0   0   0   0   0   0   0   0   0\n2008   0   0   0   0   0   0   0   0   0   0   0   0\n2009   0   0   0   1   0   0   0   0   0   0   0   0\n2010   0   0   0   0   0   0   0   0   0   0   0   0\n2011   0   0   0   0   0   0   0   0   0   0   0   0\n2012   0   0   0   0   0   0   0   0   0   0   0   0\n2013   0   0   0   0   0   0   0   0   0   0   0   0\n2014   0   0   0   0   0   0   0   0   0   0   0   0\n2015   0   0   0   0   0   0   0   0   0   0   0   0\n2016   0   0   0   0   0   0   0   0   0   0   0   0\n2017   0   0   0   0   0   0   0   0   0   0   0   0\n2018   0   0   0   0   0   0   0   0   0   0   0   0\n2019   0   0   0   0   0   0   0   0   0   0   0   0\n2020   0                                            \n```\n:::\n:::\n\nOption 2 : utiliser `time()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nindicatrice <- ts(0, start = 2000, end = 2020, frequency = 12)\n# Donne un vecteur de booléens\n(time(indicatrice) == 2009 + 3/12) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       Jan   Feb   Mar   Apr   May   Jun   Jul   Aug   Sep   Oct   Nov   Dec\n2000 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2001 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2002 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2003 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2004 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2005 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2006 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2007 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2008 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2009 FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2010 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2011 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2012 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2013 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2014 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2015 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2016 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2017 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2018 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2019 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n2020 FALSE                                                                  \n```\n:::\n\n```{.r .cell-code}\n# on ajoute + 0 pour forcer la convertion en numérique\n(time(indicatrice) == 2009 + 3/12) + 0\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n2000   0   0   0   0   0   0   0   0   0   0   0   0\n2001   0   0   0   0   0   0   0   0   0   0   0   0\n2002   0   0   0   0   0   0   0   0   0   0   0   0\n2003   0   0   0   0   0   0   0   0   0   0   0   0\n2004   0   0   0   0   0   0   0   0   0   0   0   0\n2005   0   0   0   0   0   0   0   0   0   0   0   0\n2006   0   0   0   0   0   0   0   0   0   0   0   0\n2007   0   0   0   0   0   0   0   0   0   0   0   0\n2008   0   0   0   0   0   0   0   0   0   0   0   0\n2009   0   0   0   1   0   0   0   0   0   0   0   0\n2010   0   0   0   0   0   0   0   0   0   0   0   0\n2011   0   0   0   0   0   0   0   0   0   0   0   0\n2012   0   0   0   0   0   0   0   0   0   0   0   0\n2013   0   0   0   0   0   0   0   0   0   0   0   0\n2014   0   0   0   0   0   0   0   0   0   0   0   0\n2015   0   0   0   0   0   0   0   0   0   0   0   0\n2016   0   0   0   0   0   0   0   0   0   0   0   0\n2017   0   0   0   0   0   0   0   0   0   0   0   0\n2018   0   0   0   0   0   0   0   0   0   0   0   0\n2019   0   0   0   0   0   0   0   0   0   0   0   0\n2020   0                                            \n```\n:::\n:::\n\n:::\n\nPour tracer un graphique il suffit maintenant d'utiliser les fonctions `plot()` et `lines()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(ts_object * 2)\nlines(ts_object, col = \"red\")\n```\n\n::: {.cell-output-display}\n![](1_Manipulation_series_temporelles_files/figure-html/plot-ts-example-1.png){width=672}\n:::\n:::\n\n\n## Séries multivariées\n\nDe la même façon que précédemment on peut créer une série temporelle multivariée.\nCette fois-ci l'objet créé est à la fois `mts`, `ts` et `matrix`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1)\n# On génère 300 observations d'une loi normale (0, 1)\nloi_normale <- rnorm(300)\nmts <- ts(matrix(loi_normale, nrow = 100, ncol = 3),\n\t\t  start = c(1961, 1), frequency = 12)\n```\n:::\n\n\nOn peut accéder à la première variable de la même façon que dans une matrice : par son nom ou son numéro de colonne :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(mts)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Series 1\" \"Series 2\" \"Series 3\"\n```\n:::\n\n```{.r .cell-code}\n# mts[,1] # ou de façon équivalente :\nmts[, \"Series 1\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n              Jan          Feb          Mar          Apr          May\n1961 -0.626453811  0.183643324 -0.835628612  1.595280802  0.329507772\n1962 -0.621240581 -2.214699887  1.124930918 -0.044933609 -0.016190263\n1963  0.619825748 -0.056128740 -0.155795507 -1.470752384 -0.478150055\n1964 -0.394289954 -0.059313397  1.100025372  0.763175748 -0.164523596\n1965 -0.112346212  0.881107726  0.398105880 -0.612026393  0.341119691\n1966  2.401617761 -0.039240003  0.689739362  0.028002159 -0.743273209\n1967  0.610726353 -0.934097632 -1.253633400  0.291446236 -0.443291873\n1968  0.593946188  0.332950371  1.063099837 -0.304183924  0.370018810\n1969 -1.276592208 -0.573265414 -1.224612615 -0.473400636             \n              Jun          Jul          Aug          Sep          Oct\n1961 -0.820468384  0.487429052  0.738324705  0.575781352 -0.305388387\n1962  0.943836211  0.821221195  0.593901321  0.918977372  0.782136301\n1963  0.417941560  1.358679552 -0.102787727  0.387671612 -0.053805041\n1964 -0.253361680  0.696963375  0.556663199 -0.688755695 -0.707495157\n1965 -1.129363096  1.433023702  1.980399899 -0.367221476 -1.044134626\n1966  0.188792300 -1.804958629  1.465554862  0.153253338  2.172611670\n1967  0.001105352  0.074341324 -0.589520946 -0.568668733 -0.135178615\n1968  0.267098791 -0.542520031  1.207867806  1.160402616  0.700213650\n1969                                                                 \n              Nov          Dec\n1961  1.511781168  0.389843236\n1962  0.074564983 -1.989351696\n1963 -1.377059557 -0.414994563\n1964  0.364581962  0.768532925\n1965  0.569719627 -0.135054604\n1966  0.475509529 -0.709946431\n1967  1.178086997 -1.523566800\n1968  1.586833455  0.558486426\n1969                          \n```\n:::\n:::\n\n\nEt avec les même fonctions que pour les matrices on peut récupérer les noms des colonnes (`colnames`), le nombre de variables (`ncol`), etc.\n\n::: {.callout-important}\n## Attention\nUne source classique d'erreur est de manipuler des séries-temporelles uni et multivariées et de vouloir utiliser les fonctions liées aux matrices sur les séries univariées. Par exemple, `colnames(ts_object)` renverra toujours l'objet `NULL`. Une solution est de tester si l'objet est multivarié avec la fonction `is.mts()`.\n:::\n\n## Manipulation basiques\n\nPour concaténer plusieurs séries temporelles, les fonctions deux fonctions suivantes peuvent `ts.union()` et `ts.intersect()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nts_object2 <- ts(1:10, frequency = 4, start = c(1960, 1))\nts.union(ts_object, ts_object2) # on garde toute la couverture temporelle en rajoutant des NA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        ts_object ts_object2\n1959 Q2         1         NA\n1959 Q3         2         NA\n1959 Q4         3         NA\n1960 Q1         4          1\n1960 Q2         5          2\n1960 Q3         6          3\n1960 Q4         7          4\n1961 Q1         8          5\n1961 Q2         9          6\n1961 Q3        10          7\n1961 Q4        NA          8\n1962 Q1        NA          9\n1962 Q2        NA         10\n```\n:::\n\n```{.r .cell-code}\nts.intersect(ts_object, ts_object2) # on ne garde que les périodes communes\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        ts_object ts_object2\n1960 Q1         4          1\n1960 Q2         5          2\n1960 Q3         6          3\n1960 Q4         7          4\n1961 Q1         8          5\n1961 Q2         9          6\n1961 Q3        10          7\n```\n:::\n:::\n\n\nOn va maintenant utiliser la série d'indice de production industrielle de la France (CVS-CJO) :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nipi_fr_manuf <- ts(c(99, 99.4, 99.7, 99.4, 100.8, 100, 98.7, 100.2, 101.2, \n100.6, 99.9, 100.9, 102.4, 100.8, 99.5, 100.7, 99.8, 99.1, 99.8, \n101.6, 100.4, 99.4, 102.8, 101, 100.2, 101.1, 102.6, 101.8, 103.7, \n103, 103.6, 103.5, 104.4, 105.6, 105.5, 105.9, 103.6, 102.9, \n103.8, 103.8, 102.5, 104.2, 104, 104.6, 103.4, 104.2, 103.4, \n103.7, 104.9, 105.8, 104.4, 104.3, 106, 103.7, 104.1, 103.1, \n103.9, 104.4), start = 2015, frequency = 12)\n```\n:::\n\n\nPour calculer la série retardée/avancée, il suffit d'utiliser la fonction `lag()` :\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# série retardée d'un mois : en février 2010 on a la valeur de janvier 2010\nlag(ipi_fr_manuf, k = -1) \n```\n:::\n\n\nLa fonction `diff` permet de calculer la différence entre deux périodes\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiff(ipi_fr_manuf, k = 1)\n```\n:::\n\n\n::: callout-note\n## Exercice\nÉcrire une fonction `ev()` qui calcule l'évolution mensuelle si la série en entrée est mensuelle, l'évolution trimestrielle si la série en entrée est trimestrielle, etc.\n\nLa fonction `ev()` transformera donc toute série $X_t$ en :\n$$\nY_t=\\frac{X_t-X_{t-1}}{\nX_{t-1}\n}=\\frac{X_t}{\nX_{t-1}\n} - 1\n$$\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\n\n\n::: {.cell}\n\n```{.r .cell-code}\nev <- function(x){\n  result <- (x/stats::lag(x, k = -1) - 1) * 100\n  return(result)\n}\n# Ou de manière équivalente :\nev2 <- function(x){\n  # Attention ici c'est bien k = 1 dans la fonction diff\n  # et k = -1 dans la fonction lag\n  result <- (diff(x, k = 1) /lag(x, k = -1)) * 100\n  return(result)\n}\n```\n:::\n\n\nRemarque : pour des raisons informatiques ces deux fonctions ne donnent pas exactement\nle même résultat. \nC'est un problème récurrent lorsque l'on souhaite tester l'égalité entre deux séries temporelles :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall(ev(ipi_fr_manuf) == ev2(ipi_fr_manuf))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\nUne solution est plutôt d'utiliser la fonction `all.equal()` :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nisTRUE(all.equal(ev(ipi_fr_manuf), ev2(ipi_fr_manuf)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n:::\n\n# Utilisation de `xts` et `zoo`\n\n## Utilisation de `xts`\n\nUn des avantages du package `xts` est qu'il permet d'appliquer une fonction à chaque période d'une série temporelle (par exemple à toutes les données trimestrielles, annuelles, etc.).\nIl s'agit des fonctions `apply.monthly()`, `apply.quarterly()`, `apply.yearly()`, etc.\nPour cela il faut auparavant convertir les données au format `xts`.\n\nPar exemple pour calculer la moyenne annuelle :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(xts)\nmoy_an <- apply.yearly(as.xts(ipi_fr_manuf), mean)\nmoy_an\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n              [,1]\ndéc 2015  99.98333\ndéc 2016 100.60833\ndéc 2017 103.40833\ndéc 2018 103.67500\noct 2019 104.46000\n```\n:::\n:::\n\n\n::: callout-note\n## Exercice\nCalculer l'évolution trimestrielle de `ipi_fr_manuf`.\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\nTout d'abord on prolonge l'IPI par des valeurs manquantes jusqu'à la fin de l'année, sinon la dernière somme sur le trimestre est fausse.\n\n::: {.cell}\n\n```{.r .cell-code}\nipi_fr_manuf_prolonge <- window(ipi_fr_manuf, end = c(2019, 12), extend = TRUE)\nsomme_trim <- apply.quarterly(as.xts(ipi_fr_manuf_prolonge), sum)\n```\n:::\n\n\nAttention la fonction lag n'agit pas pareil pour les objets xts et ts : il faut ici utiliser l'option `k = 1`.\nVoir l'aide associée à `?lag.xts`.\nPour garder la même convention entre `lag.ts()` et `lag.xts()` on peut utiliser l'option `options(xts.compat.zoo.lag=TRUE)`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nevol_trim <- (somme_trim/lag(somme_trim, k = 1) - 1) * 100\n```\n:::\n\n\nOn peut utiliser la fonction `format()` si l'on veut convertir automatiquement en un objet ts :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstart_year <- as.numeric(format(start(evol_trim), \"%Y\"))\nstart_quarter <- as.numeric(substr(quarters(start(evol_trim)), 2, 2))\nts(evol_trim, start = c(start_year, start_quarter), frequency = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            Qtr1        Qtr2        Qtr3        Qtr4\n2015          NA  0.70446159 -0.03331113  0.43318894\n2016  0.43132050 -1.02411629  0.73431242  0.46388337\n2017  0.23087071  1.51365581  0.97244733  1.76565008\n2018 -2.11356467  0.06445375  0.48309179 -0.22435897\n2019  1.22068744 -0.34909553 -0.92356688          NA\n```\n:::\n:::\n\nOn peut aussi directement utiliser le package `ts_box` et la fonction `ts_ts()` :\n\n::: {.cell}\n\n```{.r .cell-code}\ntsbox::ts_ts(evol_trim)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            Qtr1        Qtr2        Qtr3        Qtr4\n2015                      NA  0.70446159 -0.03331113\n2016  0.43318894  0.43132050 -1.02411629  0.73431242\n2017  0.46388337  0.23087071  1.51365581  0.97244733\n2018  1.76565008 -2.11356467  0.06445375  0.48309179\n2019 -0.22435897  1.22068744 -0.34909553 -0.92356688\n2020          NA                                    \n```\n:::\n:::\n\n:::\n\nOn aurait en fait pu le faire directement avec les fonctions de base R !\nPar contre la situation aurait été plus compliquée avec des données haute fréquence (du type journalières) non gérées par `ts` :\n\n\n::: {.cell}\n\n```{.r .cell-code}\naggregate(ipi_fr_manuf, nfrequency = 4,\n\t\t  FUN = mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          Qtr1      Qtr2      Qtr3      Qtr4\n2015  99.36667 100.06667 100.03333 100.46667\n2016 100.90000  99.86667 100.60000 101.06667\n2017 101.30000 102.83333 103.83333 105.66667\n2018 103.43333 103.50000 104.00000 103.76667\n2019 105.03333 104.66667 103.70000          \n```\n:::\n:::\n\n\n## Utilisation de `zoo`\n\nLe package `zoo` donne un ensemble d'outils qui permettent de manipuler les séries-temporelles.\nDe nombreux packages (dont `xts`) sont d'ailleurs basés sur ce format.\nIl permet notamment de faire des imputations de données manquantes selon différentes fonctions (toutes les fonctions commençant par `na.`) et de mieux gérer le format des dates associées aux séries temporelles (ce qui permet de faire des manipulations avec la fonction `format`, ce qui permet par exemple plus facilement exporter des séries temporelles sous Excel).\nLe calcul de l'évolution trimestrielle aurait par exemple pu être faite avec ce package :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsomme_trim <- aggregate(as.zoo(ipi_fr_manuf_prolonge), yearqtr, sum)\nsomme_trim <- as.ts(somme_trim) #La conversion en ts est plus simple depuis un objet zoo\nevol_trim <- ev(somme_trim)\nevol_trim\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            Qtr1        Qtr2        Qtr3        Qtr4\n2015              0.70446159 -0.03331113  0.43318894\n2016  0.43132050 -1.02411629  0.73431242  0.46388337\n2017  0.23087071  1.51365581  0.97244733  1.76565008\n2018 -2.11356467  0.06445375  0.48309179 -0.22435897\n2019  1.22068744 -0.34909553 -0.92356688          NA\n```\n:::\n:::\n\n\nPour le prochain exercice, utiliser la série suivante :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nserie_avec_NA <- ts(c(NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 0, 0, 0, 0, \n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NA, \n  NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, \n  NA, NA, NA, NA, NA, NA, NA, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, NA, NA, NA, NA, NA, NA, \n  NA, NA, NA, NA, NA, NA), start = 2000, frequency = 12)\n```\n:::\n\n\n::: callout-note\n## Exercice\nSur la série `serie_avec_NA`, utiliser les différentes fonctions du package `zoo` pour :\n\n1. Enlever les valeurs manquantes au début de la série ;  \n2. Remplacer les valeurs manquantes à la fin de la série par la dernière valeur observée.  \n3. Interpoler de manière linéaire les valeurs manquantes entre les 0 et les 1.\n:::\n\n::: {.callout-caution collapse=\"true\"}\n## Indice\nLes trois fonctions à utiliser sont : `na.trim()`, `na.locf` et `na.approx()`. \nIl faudra peut-être inverser deux étapes pour que cela marche.\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\nD'abord on enlève les valeurs manquantes au début de la série\n\n::: {.cell}\n\n```{.r .cell-code}\netape_1 <- na.trim(serie_avec_NA, sides = \"left\")\netape_1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n2001   0   0   0   0   0   0   0   0   0   0   0   0\n2002   0   0   0   0   0   0   0   0   0   0   0   0\n2003  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA\n2004  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA\n2005   1   1   1   1   1   1   1   1   1   1   1   1\n2006   1   1   1   1   1   1   1   1   1   1   1   1\n2007  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA  NA\n```\n:::\n:::\n\n\nEnsuite on interpole\n\n\n::: {.cell}\n\n```{.r .cell-code}\netape_2 <- na.approx(etape_1, na.rm = FALSE)\netape_2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Jan  Feb  Mar  Apr  May  Jun  Jul  Aug  Sep  Oct  Nov  Dec\n2001 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00\n2002 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00\n2003 0.04 0.08 0.12 0.16 0.20 0.24 0.28 0.32 0.36 0.40 0.44 0.48\n2004 0.52 0.56 0.60 0.64 0.68 0.72 0.76 0.80 0.84 0.88 0.92 0.96\n2005 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00\n2006 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00\n2007   NA   NA   NA   NA   NA   NA   NA   NA   NA   NA   NA   NA\n```\n:::\n:::\n\n\nEnfin on remplace les valeurs à la fin de la série\n\n\n::: {.cell}\n\n```{.r .cell-code}\netape_3 <- na.locf(etape_2)\netape_3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Jan  Feb  Mar  Apr  May  Jun  Jul  Aug  Sep  Oct  Nov  Dec\n2001 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00\n2002 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00\n2003 0.04 0.08 0.12 0.16 0.20 0.24 0.28 0.32 0.36 0.40 0.44 0.48\n2004 0.52 0.56 0.60 0.64 0.68 0.72 0.76 0.80 0.84 0.88 0.92 0.96\n2005 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00\n2006 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00\n2007 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00 1.00\n```\n:::\n:::\n\n:::\n\n::: callout-note\n## Exercice\nÀ l'aide des fonctions `as.yearmon()` et `format()`, créer un data.frame contenant une colonne \"date\" qui contient les dates au format JJ/MM/YYYY et une deuxième colonnes avec les valeurs de `ipi_fr_manuf`.\n:::\n\n::: {.callout-caution collapse=\"true\"}\n## Indice\nLa fonction `as.yearmon()` doit être appliquée sur `time(ipi_fr_manuf)`. Pour la fonction `format` regarder l'aide `?format.Date`.\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\n\n::: {.cell}\n\n```{.r .cell-code}\ndates <- as.yearmon(time(ipi_fr_manuf))\ndates <- format(dates, \"%d/%m/%Y\")\ndonnees_formatees <- data.frame(date = dates, ipi = ipi_fr_manuf)\nhead(donnees_formatees)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        date   ipi\n1 01/01/2015  99.0\n2 01/02/2015  99.4\n3 01/03/2015  99.7\n4 01/04/2015  99.4\n5 01/05/2015 100.8\n6 01/06/2015 100.0\n```\n:::\n:::\n\n:::\n\nIl peut également être utile d'exporter un objet R `ts` ou `mts` vers un fichier Excel, tout en rajoutant une colonne \"date\" qui sera au format date.\nCi-dessous un exemple en utilisant le package XLConnect :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(XLConnect)\nts2xls <- function(x, file, sheet=\"Feuille 1\", format = \"dd/mm/yyyy\"){\n  wb <- loadWorkbook(file, create = TRUE)\n  createSheet(wb, sheet)\n  if(is.mts(x)){\n    col <- c(\"date\", colnames(x))\n  }else{\n    col <- c(\"date\", \"x\")\n  }\n  # Le titre\n  writeWorksheet(wb,matrix(col,nrow = 1),\n                 sheet = sheet,startCol = 1,startRow =1,\n                 header = FALSE)\n\n  # Petit trick pour que la colonne date soit au format date d'Excel\n  csDate <- getOrCreateCellStyle(wb, name = \"date\")\n  setDataFormat(csDate, format = format)\n  date <- as.Date(format(zoo::as.Date((time(x))), \"%d/%m/%Y\"),\n                  \"%d/%m/%Y\")\n  writeWorksheet(wb,date,sheet = sheet,\n                 startCol = 1,startRow = 2,\n                 header = FALSE)\n  setCellStyle(wb, sheet = sheet, row = seq_along(date)+1,\n               col = 1,\n               cellstyle = csDate)\n  # Fin colonne date\n\n  # Autres colonnes\n  writeWorksheet(wb,x,sheet = sheet,startCol = 2,startRow = 2,\n                 header = FALSE)\n  setColumnWidth(wb, sheet, column = seq_along(col), width = -1)\n  saveWorkbook(wb, file)\n}\n```\n:::\n\n\n# Manipulation avec `tsibble`\n\nLe format `tsibble` est un autre format de gestion des séries temporelles\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tsibble)\nmts_tsibble <- as_tsibble(mts)\nipi_tsibble <- as_tsibble(ipi_fr_manuf)\n```\n:::\n\n\n::: callout-note\n## Exercice\nCalculer les moyennes trimestrielles de chaque série de `mts_tsibble` et `ipi_tsibble`.\n:::\n\n::: {.callout-caution collapse=\"true\"}\n## Indice\nIl faut utiliser à la fois `index_by` et `group_by_key()`.\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nmts_tsibble %>%  \n\tgroup_by_key() %>% \n\tindex_by(date = ~ yearquarter(.)) %>%\n\tsummarise(moy = mean(value))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tsibble: 102 x 3 [1Q]\n# Key:       key [3]\n   key         date    moy\n   <chr>      <qtr>  <dbl>\n 1 Series 1 1961 Q1 -0.426\n 2 Series 1 1961 Q2  0.368\n 3 Series 1 1961 Q3  0.601\n 4 Series 1 1961 Q4  0.532\n 5 Series 1 1962 Q1 -0.570\n 6 Series 1 1962 Q2  0.294\n 7 Series 1 1962 Q3  0.778\n 8 Series 1 1962 Q4 -0.378\n 9 Series 1 1963 Q1  0.136\n10 Series 1 1963 Q2 -0.510\n# … with 92 more rows\n```\n:::\n\n```{.r .cell-code}\nipi_tsibble %>%  \n\tgroup_by_key() %>% \n\tindex_by(date = ~ yearquarter(.)) %>%\n\tsummarise(moy = mean(value))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tsibble: 20 x 2 [1Q]\n      date   moy\n     <qtr> <dbl>\n 1 2015 Q1  99.4\n 2 2015 Q2 100. \n 3 2015 Q3 100. \n 4 2015 Q4 100. \n 5 2016 Q1 101. \n 6 2016 Q2  99.9\n 7 2016 Q3 101. \n 8 2016 Q4 101. \n 9 2017 Q1 101. \n10 2017 Q2 103. \n11 2017 Q3 104. \n12 2017 Q4 106. \n13 2018 Q1 103. \n14 2018 Q2 104. \n15 2018 Q3 104  \n16 2018 Q4 104. \n17 2019 Q1 105. \n18 2019 Q2 105. \n19 2019 Q3 104. \n20 2019 Q4 104. \n```\n:::\n:::\n\n:::\n\n::: callout-note\n## Exercice\n1. En utilisant la fonction `dplyr::full_join()`, créer un objet `tsibble` contenant les valeurs de `mts_tsibble` et `ipi_tsibble`. \n2. Comparer les résultats avec `dplyr::left_join()` et `dplyr::right_join()`.\n3. Quelle serait l'équivalent de `ts.intersect()` et `ts.union()` ?\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\n\n::: {.cell}\n\n```{.r .cell-code}\nmts_tsibble %>%  full_join(ipi_tsibble, by = \"index\") # comme ts.union()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tsibble: 358 x 4 [1M]\n# Key:       key [4]\n      index key      value.x value.y\n      <mth> <chr>      <dbl>   <dbl>\n 1 1961 jan Series 1  -0.626      NA\n 2 1961 fév Series 1   0.184      NA\n 3 1961 mar Series 1  -0.836      NA\n 4 1961 avr Series 1   1.60       NA\n 5 1961 mai Series 1   0.330      NA\n 6 1961 jui Series 1  -0.820      NA\n 7 1961 jul Series 1   0.487      NA\n 8 1961 aoû Series 1   0.738      NA\n 9 1961 sep Series 1   0.576      NA\n10 1961 oct Series 1  -0.305      NA\n# … with 348 more rows\n```\n:::\n\n```{.r .cell-code}\nmts_tsibble %>%  left_join(ipi_tsibble, by = \"index\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tsibble: 300 x 4 [1M]\n# Key:       key [3]\n      index key      value.x value.y\n      <mth> <chr>      <dbl>   <dbl>\n 1 1961 jan Series 1  -0.626      NA\n 2 1961 fév Series 1   0.184      NA\n 3 1961 mar Series 1  -0.836      NA\n 4 1961 avr Series 1   1.60       NA\n 5 1961 mai Series 1   0.330      NA\n 6 1961 jui Series 1  -0.820      NA\n 7 1961 jul Series 1   0.487      NA\n 8 1961 aoû Series 1   0.738      NA\n 9 1961 sep Series 1   0.576      NA\n10 1961 oct Series 1  -0.305      NA\n# … with 290 more rows\n```\n:::\n\n```{.r .cell-code}\nmts_tsibble %>%  right_join(ipi_tsibble, by = \"index\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tsibble: 58 x 4 [1M]\n# Key:       key [1]\n      index key   value.x value.y\n      <mth> <chr>   <dbl>   <dbl>\n 1 2015 jan <NA>       NA    99  \n 2 2015 fév <NA>       NA    99.4\n 3 2015 mar <NA>       NA    99.7\n 4 2015 avr <NA>       NA    99.4\n 5 2015 mai <NA>       NA   101. \n 6 2015 jui <NA>       NA   100  \n 7 2015 jul <NA>       NA    98.7\n 8 2015 aoû <NA>       NA   100. \n 9 2015 sep <NA>       NA   101. \n10 2015 oct <NA>       NA   101. \n# … with 48 more rows\n```\n:::\n\n```{.r .cell-code}\nmts_tsibble %>%  inner_join(ipi_tsibble, by = \"index\") # ts.intersect\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tsibble: 0 x 4 [?]\n# Key:       key [0]\n# … with 4 variables: index <mth>, key <chr>, value.x <dbl>, value.y <dbl>\n```\n:::\n:::\n\n:::\n\nLes *index* vont être des dates : on peut facilement les manipuler en utilisant le package `lubdridate`.\nPar exemple pour ne que garder que les dates à partir de l'année 2000 :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(lubridate)\nipi_tsibble %>% \n\tfilter(year(index) >= 2000)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tsibble: 58 x 2 [1M]\n      index value\n      <mth> <dbl>\n 1 2015 jan  99  \n 2 2015 fév  99.4\n 3 2015 mar  99.7\n 4 2015 avr  99.4\n 5 2015 mai 101. \n 6 2015 jui 100  \n 7 2015 jul  98.7\n 8 2015 aoû 100. \n 9 2015 sep 101. \n10 2015 oct 101. \n# … with 48 more rows\n```\n:::\n:::\n\n\nPour extraire les données à partir d'un certain mois (mars 2018 par exemple) on peut utiliser la fonction `tsibble::make_yearmonth()` :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nipi_tsibble %>% \n\tfilter(index >= make_yearmonth(2000,6))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tsibble: 58 x 2 [1M]\n      index value\n      <mth> <dbl>\n 1 2015 jan  99  \n 2 2015 fév  99.4\n 3 2015 mar  99.7\n 4 2015 avr  99.4\n 5 2015 mai 101. \n 6 2015 jui 100  \n 7 2015 jul  98.7\n 8 2015 aoû 100. \n 9 2015 sep 101. \n10 2015 oct 101. \n# … with 48 more rows\n```\n:::\n:::\n\n\n::: {.callout-note}\n## Exercice\nÀ l'aide du package `lubridate`, extraire toutes les données du mois de janvier et juillet de l'objet `ipi_tsibble`.\n:::\n\n::: {.callout-caution collapse=\"true\"}\n## Indice\nRegarder ce que donne \n\n\n::: {.cell}\n\n```{.r .cell-code}\nipi_tsibble %>% mutate(month = lubridate::month(index))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tsibble: 58 x 3 [1M]\n      index value month\n      <mth> <dbl> <dbl>\n 1 2015 jan  99       1\n 2 2015 fév  99.4     2\n 3 2015 mar  99.7     3\n 4 2015 avr  99.4     4\n 5 2015 mai 101.      5\n 6 2015 jui 100       6\n 7 2015 jul  98.7     7\n 8 2015 aoû 100.      8\n 9 2015 sep 101.      9\n10 2015 oct 101.     10\n# … with 48 more rows\n```\n:::\n:::\n\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(lubridate)\nipi_tsibble %>% \n\tfilter(month(index) %in% c(1,7))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tsibble: 10 x 2 [1M]\n      index value\n      <mth> <dbl>\n 1 2015 jan  99  \n 2 2015 jul  98.7\n 3 2016 jan 102. \n 4 2016 jul  99.8\n 5 2017 jan 100. \n 6 2017 jul 104. \n 7 2018 jan 104. \n 8 2018 jul 104  \n 9 2019 jan 105. \n10 2019 jul 104. \n```\n:::\n:::\n\n:::\n\n::: {.callout-important}\n## Attention\nUne fois que l'on a chargé `dplyr`, la fonction `lag()` utilisée par défaut est modifiée ! \nEssayez par exemple de relancer le code `ev2(ipi_fr_manuf)`. \nComment alors modifier la fonction `ev2()` pour éviter d'avoir une erreur ?\n\nUne façon de faire est de remplacer les `lag()` par des `stats::lag()` pour forcer l'utilisation de la fonction `lag()` du package `stats`. \nSi l'on veut éviter les erreurs de conflits entre les packages, on peut utiliser le package [`conflicted`](https://conflicted.r-lib.org).\n:::\n",
    "supporting": [
      "1_Manipulation_series_temporelles_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}